import{w as j,m as K,$ as V}from"./index-xP-VuMjv.js";import{s as Y,m as J,cQ as z,e as X,l as Z,v as ee,u as te,y as se,B as oe,ax as re,dM as ae,d2 as ie,cS as ne,d6 as q,a5 as ue}from"./n8n-_nNvRoCf.js";import{d as le,m as de}from"./pinia-aUqqC48i.js";import{p as ce}from"./flatted-jPn12Tq4.js";import{u as he,a as we}from"./collaboration.store-emJMSzVB.js";import{G as fe}from"./vendor-NNwioulI.js";const pe="/orchestration/worker/status",ke=async e=>{await Y(e,"POST",pe)},ge=100,me=120*1e3,Se=le("orchestrationManager",{state:()=>({initialStatusReceived:!1,workers:{},workersHistory:{},workersLastUpdated:{},statusInterval:null}),actions:{updateWorkerStatus(e){this.workers[e.workerId]=e,this.workersHistory[e.workerId]||(this.workersHistory[e.workerId]=[]),this.workersHistory[e.workerId].push({data:e,timestamp:Date.now()}),this.workersHistory[e.workerId].length>ge&&this.workersHistory[e.workerId].shift(),this.workersLastUpdated[e.workerId]=Date.now(),this.initialStatusReceived=!0},removeStaleWorkers(){for(const e in this.workersLastUpdated)this.workersLastUpdated[e]+me<Date.now()&&(delete this.workers[e],delete this.workersHistory[e],delete this.workersLastUpdated[e])},startWorkerStatusPolling(){const e=J();this.statusInterval||(this.statusInterval=setInterval(async()=>{await ke(e.getRestApiContext),this.removeStaleWorkers()},1e3))},stopWorkerStatusPolling(){this.statusInterval&&(clearInterval(this.statusInterval),this.statusInterval=null)},getWorkerLastUpdated(e){return this.workersLastUpdated[e]??0},getWorkerStatus(e){return this.workers[e]},getWorkerStatusHistory(e){return this.workersHistory[e]??[]}}}),ve=fe({mixins:[j],setup(){return{...z(),...X(),nodeHelpers:K()}},data(){return{retryTimeout:null,pushMessageQueue:[],removeEventListener:null}},created(){this.removeEventListener=this.pushStore.addEventListener(e=>{this.pushMessageReceived(e)})},unmounted(){typeof this.removeEventListener=="function"&&this.removeEventListener()},computed:{...de(oe,se,te,ee,Z,V,Se,we,he),sessionId(){return this.rootStore.sessionId}},methods:{queuePushMessage(e,r){this.pushMessageQueue.push({message:e,retriesLeft:r}),this.retryTimeout===null&&(this.retryTimeout=setTimeout(this.processWaitingPushMessages,20))},async processWaitingPushMessages(){this.retryTimeout!==null&&(clearTimeout(this.retryTimeout),this.retryTimeout=null);const e=this.pushMessageQueue.length;for(let r=0;r<e;r++){const n=this.pushMessageQueue.shift();if(!await this.pushMessageReceived(n.message,!0)){n.retriesLeft-=1,n.retriesLeft>0&&this.pushMessageQueue.unshift(n);break}}this.pushMessageQueue.length!==0&&this.retryTimeout===null&&(this.retryTimeout=setTimeout(this.processWaitingPushMessages,25))},async pushMessageReceived(e,r){var f,g,m,S,x,y,E,T,I,N,v,D,M,W,A,b,R,C,L,$,P,H,O,_,U,F,B,G;if(e.type==="sendWorkerStatusMessage"){const s=e.data;return this.orchestrationManagerStore.updateWorkerStatus(s.status),!0}if(e.type==="sendConsoleMessage"){const s=e.data;return console.log(s.source,...s.messages),!0}if(!["testWebhookReceived"].includes(e.type)&&r!==!0&&this.pushMessageQueue.length)return this.queuePushMessage(e,5),!1;if(e.type==="nodeExecuteAfter"||e.type==="nodeExecuteBefore"){if(!this.uiStore.isActionActive("workflowRunning"))return!1;const s=e.data;if(this.workflowsStore.activeExecutionId!==s.executionId)return r!==!0&&this.queuePushMessage(event,5),!1}let c;if(e.type==="executionRecovered"){const s=(f=e.data)==null?void 0:f.executionId;if(this.uiStore.isActionActive("workflowRunning")&&this.workflowsStore.activeExecutionId===s){const t=await this.workflowsStore.fetchExecutionDataById(this.workflowsStore.activeExecutionId);if(t!=null&&t.data){t.data=ce(t.data);const d={startData:(g=t.data)==null?void 0:g.startData,resultData:((m=t.data)==null?void 0:m.resultData)??{runData:{}},executionData:(S=t.data)==null?void 0:S.executionData};if(((x=this.workflowsStore.workflowExecutionData)==null?void 0:x.workflowId)===t.workflowId){const u=(T=(E=(y=this.workflowsStore.workflowExecutionData)==null?void 0:y.data)==null?void 0:E.resultData)==null?void 0:T.runData;if(u)for(const w of Object.keys(u))d.resultData.runData[w]=u[w]}const p={data:d,finished:t.finished,mode:t.mode,waitTill:(I=t.data)==null?void 0:I.waitTill,startedAt:t.startedAt,stoppedAt:t.stoppedAt,status:"crashed"};t.data&&(c={executionId:t.id,data:p})}}}if(e.type==="workflowFailedToActivate"&&this.workflowsStore.workflowId===e.data.workflowId)return this.workflowsStore.setWorkflowInactive(e.data.workflowId),this.workflowsStore.setActive(!1),this.showError(new Error(e.data.errorMessage),this.$locale.baseText("workflowActivator.showError.title",{interpolate:{newStateName:"activated"}})+":"),!0;if(e.type==="workflowActivated")return this.workflowsStore.setWorkflowActive(e.data.workflowId),!0;if(e.type==="workflowDeactivated")return this.workflowsStore.setWorkflowInactive(e.data.workflowId),!0;if(e.type==="executionFinished"||e.type==="executionRecovered"){let s;if(e.type==="executionRecovered"&&c!==void 0?s=c:s=e.data,this.workflowsStore.activeExecutionId===s.executionId){const o=(D=(v=(N=this.workflowsStore.workflowExecutionData)==null?void 0:N.data)==null?void 0:v.resultData)==null?void 0:D.runData;if(o)for(const a of Object.keys(o))((L=(C=(R=(b=(A=(W=(M=s.data.data.resultData.runData[a])==null?void 0:M[0])==null?void 0:W.data)==null?void 0:A.main)==null?void 0:b[0])==null?void 0:R[0])==null?void 0:C.json)==null?void 0:L.isArtificialRecoveredEventItem)===!0&&o[a].length>0&&(s.data.data.resultData.runData[a]=o[a]);this.workflowsStore.finishActiveExecution(s)}if(!this.uiStore.isActionActive("workflowRunning"))return!1;const{activeExecutionId:h}=this.workflowsStore;if(h!==s.executionId)return r!==!0&&this.queuePushMessage(event,5),!1;const t=s.data;let d=this.getExecutionError(t.data);t.status==="crashed"?d=this.$locale.baseText("pushConnection.executionFailed.message"):t.status==="canceled"&&(d=this.$locale.baseText("executionsList.showMessage.stopExecution.message",{interpolate:{activeExecutionId:h}}));const p=(H=(P=($=t==null?void 0:t.data)==null?void 0:$.resultData)==null?void 0:P.error)==null?void 0:H.lineNumber;re.emit("error-line-number",p||"final");const u=this.getCurrentWorkflow();if(t.waitTill!==void 0){const o=this.workflowsStore.activeExecutionId,a=this.workflowsStore.workflowSettings,i=this.rootStore.saveManualExecutions,l=a.saveManualExecutions===void 0?i:a.saveManualExecutions;let k;l?k=`<a href="/workflow/${u.id}/executions/${o}">View the execution</a> to see what happened after this node.`:(ae.emit("registerGlobalLinkAction",{key:"open-settings",action:async()=>{this.workflowsStore.isNewWorkflow&&await this.saveAsNewWorkflow(),this.uiStore.openModal(ie)}}),k='<a data-action="open-settings">Turn on saving manual executions</a> and run again to see what happened after this node.'),this.titleSet(u.name,"IDLE"),this.showToast({title:"Workflow started waiting",message:`${k} <a href="https://docs.n8n.io/integrations/builtin/core-nodes/n8n-nodes-base.wait/" target="_blank">More info</a>`,type:"success",duration:0})}else if(t.finished!==!0){if(this.titleSet(u.name,"ERROR"),((O=t.data.resultData.error)==null?void 0:O.name)==="ExpressionError"&&t.data.resultData.error.context.functionality==="pairedItem"){const o=t.data.resultData.error;this.getWorkflowDataToSave().then(a=>{const i={caused_by_credential:!1,error_message:o.description,error_title:o.message,error_type:o.context.type,node_graph_string:JSON.stringify(ne(a,this.getNodeTypes()).nodeGraph),workflow_id:this.workflowsStore.workflowId};if(o.context.nodeCause&&["no pairing info","invalid pairing info"].includes(o.context.type)){const l=u.getNode(o.context.nodeCause);l&&(i.is_pinned=!!u.getPinDataOfNode(l.name),i.mode=l.parameters.mode,i.node_type=l.type,i.operation=l.parameters.operation,i.resource=l.parameters.resource)}this.$telemetry.track("Instance FE emitted paired item error",i,{withPostHog:!0})})}if(((_=t.data.resultData.error)==null?void 0:_.name)==="SubworkflowOperationError"){const o=t.data.resultData.error;this.workflowsStore.subWorkflowExecutionError=o,this.showMessage({title:o.message,message:o.description,type:"error",duration:0})}else if(((U=t.data.resultData.error)==null?void 0:U.name)==="NodeOperationError"&&t.data.resultData.error.functionality==="configuration-node"){let o;const a=t.data.resultData.error;a.node.name?o=`Error in sub-node ‘${a.node.name}‘`:o="Problem executing workflow",this.showMessage({title:o,message:((a==null?void 0:a.description)??d)+this.$locale.baseText("pushConnection.executionError.openNode",{interpolate:{node:a.node.name}}),type:"error",duration:0,dangerouslyUseHTMLString:!0})}else{let o;t.mode==="manual"&&t.status==="canceled"?this.showMessage({title:this.$locale.baseText("nodeView.showMessage.stopExecutionTry.title"),type:"success"}):(t.data.resultData.lastNodeExecuted?o=`Problem in node ‘${t.data.resultData.lastNodeExecuted}‘`:o="Problem executing workflow",this.showMessage({title:o,message:d,type:"error",duration:0,dangerouslyUseHTMLString:!0}))}}else{this.titleSet(u.name,"IDLE");const o=this.workflowsStore.getWorkflowExecution;if(o!=null&&o.executedNode){const a=this.workflowsStore.getNodeByName(o.executedNode),i=a&&this.nodeTypesStore.getNodeType(a.type,a.typeVersion),l=o&&o.executedNode&&((G=(B=(F=o.data)==null?void 0:F.resultData)==null?void 0:B.runData)==null?void 0:G[o.executedNode]);i!=null&&i.polling&&!l?this.showMessage({title:this.$locale.baseText("pushConnection.pollingNode.dataNotFound",{interpolate:{service:q(i)}}),message:this.$locale.baseText("pushConnection.pollingNode.dataNotFound.message",{interpolate:{service:q(i)}}),type:"success"}):this.showMessage({title:this.$locale.baseText("pushConnection.nodeExecutedSuccessfully"),type:"success"})}else this.showMessage({title:this.$locale.baseText("pushConnection.workflowExecutedSuccessfully"),type:"success"})}this.workflowsStore.getWorkflowRunData&&(t.data.resultData.runData=this.workflowsStore.getWorkflowRunData),this.workflowsStore.executingNode.length=0,this.workflowsStore.setWorkflowExecutionData(t),this.uiStore.removeActiveAction("workflowRunning"),this.nodeHelpers.updateNodesExecutionIssues();const w=t.data.resultData.lastNodeExecuted;let Q=0;w&&t.data.resultData.runData[w]&&!d&&(Q=t.data.resultData.runData[w][0].data.main[0].length),ue().run("pushConnection.executionFinished",{itemsCount:Q,nodeName:t.data.resultData.lastNodeExecuted,errorMessage:d,runDataExecutedStartData:t.data.startData,resultDataError:t.data.resultData.error}),t.data.resultData.error||this.segmentStore.trackSuccessfulWorkflowExecution(t)}else if(e.type==="executionStarted"){const s=e.data,h={id:s.executionId,finished:!1,mode:s.mode,startedAt:s.startedAt,retryOf:s.retryOf,workflowId:s.workflowId,workflowName:s.workflowName};this.workflowsStore.addActiveExecution(h)}else if(e.type==="nodeExecuteAfter"){const s=e.data;this.workflowsStore.addNodeExecutionData(s),this.workflowsStore.removeExecutingNode(s.nodeName)}else if(e.type==="nodeExecuteBefore"){const s=e.data;this.workflowsStore.addExecutingNode(s.nodeName)}else if(e.type==="testWebhookDeleted")e.data.workflowId===this.workflowsStore.workflowId&&(this.workflowsStore.executionWaitingForWebhook=!1,this.uiStore.removeActiveAction("workflowRunning"));else if(e.type==="testWebhookReceived"){const s=e.data;s.workflowId===this.workflowsStore.workflowId&&(this.workflowsStore.executionWaitingForWebhook=!1,this.workflowsStore.activeExecutionId=s.executionId),this.processWaitingPushMessages()}else if(e.type==="reloadNodeType")await this.nodeTypesStore.getNodeTypes(),await this.nodeTypesStore.getFullNodesProperties([e.data]);else if(e.type==="removeNodeType"){const h=[e.data];await this.credentialsStore.fetchCredentialTypes(!1).then(()=>{this.nodeTypesStore.removeNodeTypes(h)})}else e.type==="nodeDescriptionUpdated"&&(await this.nodeTypesStore.getNodeTypes(),await this.credentialsStore.fetchCredentialTypes(!0));return!0},getExecutionError(e){const r=e.resultData.error;let n;if(e.resultData.lastNodeExecuted&&r)n=r.message||r.description;else if(n=this.$locale.baseText("pushConnection.executionError",{interpolate:{error:"!"}}),r!=null&&r.message){let c;"node"in r&&(c=typeof r.node=="string"?r.node:r.node.name);const f=c?`${c}: ${r.message}`:r.message;n=this.$locale.baseText("pushConnection.executionError",{interpolate:{error:`.${this.$locale.baseText("pushConnection.executionError.details",{interpolate:{details:f}})}`}})}return n}}});export{ge as W,ve as p,Se as u};
//# sourceMappingURL=pushConnection-PNUo6dZ9.js.map
